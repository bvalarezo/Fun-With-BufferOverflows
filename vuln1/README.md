## Vuln1

###Strategy

This simple program will take input from the `argv`, copy this input into a buffer, and print the buffer to stdout.

If the character contains [hijklmn], it will be mangled and replaced by 'x'

This program is vulnerable to a buffer overflow and is compiled to have an executable stack. A payload that contains shellcode can be used to pop a shell.

Our shellcode was generated by `msfvenom` with this command.

	msfvenom -p linux/x86/shell_bind_tcp -f python -b '\x00\x68\x69\x6a\x6b\x6c\x6d\x6e'

>Note: -b are the characters we want to avoid, since they will get mangled.

To overflow to the return address, we need to calculate the amount of bytes it takes to get there. 
```C
unsigned int i; // 4 bytes
char buf[256]; // 256 bytes
```
 Thats 260 bytes, plus 4 for the frame pointer, plus another 4(zero padding in GDB. Not sure exactly).

The return address is offset by 268 bytes, the next 4 bytes **is** the return address.

To get the return address, we can use GDB and anaylze what address on the stack is `char buf[256]`.

At the time of this writeup, I got the address `0xbf928694` to the address at the beginning of the buffer. So, let this be the return address. 

To get this value, I opened up the program in `gdb(1)` and ran this command...

	run `python -c 'print "CCCC" + "A"*264 + "BBBB"'`

and 
	
	x/268x $esp

To get the idea of memory on the stack. 

`hack.py` is our python script that will launch the program with the malicious payload.

I generated an encoded payload as such

	msfvenom -p linux/x86/exec CMD=/bin/sh -a x86 --platform linux -f python -b '\x00\x68\x69\x6a\x6b\x6c\x6d\x6e\x10\x09\x0a'
