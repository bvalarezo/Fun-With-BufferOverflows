## Vuln1

### Strategy

This simple program will take input from the `argv`, copy this input into a buffer, and print the buffer to stdout.

If the character contains [hijklmn], it will be mangled and replaced by 'x'

This program is vulnerable to a buffer overflow and is compiled to have an executable stack. A payload that contains shellcode can be used to pop a shell.

Our shellcode was generated by `msfvenom` with this command.

	msfvenom -p linux/x86/exec CMD=/bin/sh -a x86 --platform linux -e x86/shikata_ga_nai -f python -b '\x00\x68\x69\x6a\x6b\x6c\x6d\x6e'

>Note: -b are the characters we want to avoid, since they will get mangled.

To overflow to the return address, we need to calculate the amount of bytes it takes to get there. 
```C
unsigned int i; // 4 bytes
char buf[256]; // 256 bytes
```
 Thats 260 bytes, plus 4 for the frame pointer, plus another 4(zero padding in GDB. Not sure exactly).

The return address is offset by 268 bytes, the next 4 bytes **is** the return address.

To get the return address, we can use GDB and anaylze what address on the stack is `char buf[256]`.

At the time of this writeup, I got the address `0xbffff504` to the address at the beginning of the buffer. So, let this be the return address. 

>Note: Be sure to disable ASLR!

To get this value, I opened up the program in `gdb(1)` and ran this command...

	run `python -c 'print "CCCC" + "A"*264 + "BBBB"'`

and 
	
	x/268x $esp

To get the idea of memory on the stack. This can help us craft a return address, to hijack the program's executation into our payload.

`hack.py` is our python script that will launch the program with the malicious payload. 

Now to create the payload. 

We can either craft the payload as such

NOP_SLED + SHELLCODE + RET

or

PADDING + RET + NOP_SLED + SHELLCODE

Where RET is an address in the NOP sled. Choosing the first format may cause the shellcode to get corrupted. This is because the stack pointer (ESP) will be a small amount of bytes away of the shellcode. If the shellcode has push or pop instructions, this can potentially corrupt the shell code can raise SIGSEGV.
To prevent this, the second format can place the shellcode away from the stack pointer (by placing it after the return address instead of before) and decrease the chance of getting corrupted.

See `hack.py` to see how we craft the payload. Also, we have to make sure that the return address(`ret_addr`) is an address in the NOP sled. This can be toggled within the python script.

### Exploitation

To pop a shell, run this command.

	./vuln1 `python hack.py`

You should have a shell!

### Resources
Thank you LiveOverflow

https://www.youtube.com/watch?v=Xvh8FkczNUc

https://www.youtube.com/watch?v=re4teYmSoXA

https://youtu.be/oS2O75H57qU
